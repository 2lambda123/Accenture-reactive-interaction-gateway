<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Architecture · Reactive Interaction Gateway</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;When we&#x27;ve designed the initial version of RIG back in 2016, we had a very specific set of problems in mind. Our mission back then was to redesign banking with state-of-the-art patterns, principles and tools - full-stack. Not surprisingly, we went for microservices, but we also wanted some sort of near real-time information flow from (potentially) &lt;em&gt;all&lt;/em&gt; those services to our web and mobile frontends. We quickly realized that there was no open-source, off-the-shelf solution for this, despite the fact that we were not the only ones with this requirement. We&#x27;ve started asking around internally and at conferences. The solution we heard most often was to use an existing backend-for-frontend service (a dedicated service for handling client requests that acts on behalf of those clients towards other backend services) and turn it into a WebSocket endpoint for frontends. We&#x27;ve also met someone who apparently implemented a solution using Lua scripts running on their Nginx reverse proxy - probably a nice implementation, but hardly scalable.&lt;/p&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Architecture · Reactive Interaction Gateway"/><meta property="og:type" content="website"/><meta property="og:url" content="https://accenture.github.io/reactive-interaction-gateway/index.html"/><meta property="og:description" content="&lt;p&gt;When we&#x27;ve designed the initial version of RIG back in 2016, we had a very specific set of problems in mind. Our mission back then was to redesign banking with state-of-the-art patterns, principles and tools - full-stack. Not surprisingly, we went for microservices, but we also wanted some sort of near real-time information flow from (potentially) &lt;em&gt;all&lt;/em&gt; those services to our web and mobile frontends. We quickly realized that there was no open-source, off-the-shelf solution for this, despite the fact that we were not the only ones with this requirement. We&#x27;ve started asking around internally and at conferences. The solution we heard most often was to use an existing backend-for-frontend service (a dedicated service for handling client requests that acts on behalf of those clients towards other backend services) and turn it into a WebSocket endpoint for frontends. We&#x27;ve also met someone who apparently implemented a solution using Lua scripts running on their Nginx reverse proxy - probably a nice implementation, but hardly scalable.&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/reactive-interaction-gateway/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/reactive-interaction-gateway/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/reactive-interaction-gateway/"><img class="logo" src="/reactive-interaction-gateway/img/icon.svg" alt="Reactive Interaction Gateway"/><h2 class="headerTitleWithLogo">Reactive Interaction Gateway</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/reactive-interaction-gateway/docs/intro.html" target="_self">User Documentation</a></li><li class=""><a href="/reactive-interaction-gateway/source_docs/index.html" target="_self">Source Documentation</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Main Concepts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/intro.html">Intro</a></li><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/tutorial.html">Tutorial</a></li><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/examples.html">Examples</a></li><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/faq.html">FAQ</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Main Concepts</h3><ul><li class="navListItem navListItemActive"><a class="navItem" href="/reactive-interaction-gateway/docs/architecture.html">Architecture</a></li><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/api-gateway.html">API Gateway</a></li><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/event-streams.html">Event Streams</a></li><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/event-subscription.html">Event Subscription</a></li><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/user-authentication.html">User authentication</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Advanced Guides</h3><ul><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/api-gateway-management.html">API Gateway Management</a></li><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/api-gateway-synchronization.html">API Gateway Synchronization</a></li><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/event-serialization.html">Event Serialization</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">RIG in Production</h3><ul><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/rig-ops-guide.html">Operator&#x27;s Guide</a></li><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/metrics-details.html">Metrics Details</a></li><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/https.html">HTTPS</a></li><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/scaling.html">Scaling</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Hacking the Source</h3><ul><li class="navListItem"><a class="navItem" href="/reactive-interaction-gateway/docs/rig-dev-guide.html">Developer&#x27;s Guide</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Architecture</h1></header><article><div><span><p>When we've designed the initial version of RIG back in 2016, we had a very specific set of problems in mind. Our mission back then was to redesign banking with state-of-the-art patterns, principles and tools - full-stack. Not surprisingly, we went for microservices, but we also wanted some sort of near real-time information flow from (potentially) <em>all</em> those services to our web and mobile frontends. We quickly realized that there was no open-source, off-the-shelf solution for this, despite the fact that we were not the only ones with this requirement. We've started asking around internally and at conferences. The solution we heard most often was to use an existing backend-for-frontend service (a dedicated service for handling client requests that acts on behalf of those clients towards other backend services) and turn it into a WebSocket endpoint for frontends. We've also met someone who apparently implemented a solution using Lua scripts running on their Nginx reverse proxy - probably a nice implementation, but hardly scalable.</p>
<p>We weren't happy with any of those solutions - they seemed kind of hacky and couldn't address all our goals.</p>
<h2><a class="anchor" aria-hidden="true" id="the-problem"></a><a href="#the-problem" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Problem</h2>
<p>RIG tackles a set of (seemingly unrelated) problems:</p>
<ul>
<li>Frontends must be able to react to any back-end event, regardless of the producing service.</li>
<li>The design must support a large number of microservices, so polling for updates is not an option.</li>
<li>Microservices must remain stateless and not be concerned with frontend connections, so a long running connection between frontend and microservice is not an option either.</li>
<li>Exposing backend events requires some sort of authorization mechanism. Especially in the banking domain, it is import to be able to kick out a logged-in user immediately (for example, when fraud is suspected).</li>
</ul>
<p>Why not introduce (connection) state for microservices? Two reasons. First, it makes re-deployment harder, unless you don't care about breaking client connections everytime you ship an update. More importantly, however, handling connection state introduces a scalability issue: assuming all frontends hold connections to all microservices, then all services need to be scaled out at the same time as soon as the number of connections exceeds the number of available TCP sockets.</p>
<h2><a class="anchor" aria-hidden="true" id="event-driven-architecture-and-the-ui"></a><a href="#event-driven-architecture-and-the-ui" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Event-Driven Architecture and the UI</h2>
<p>Forwarding events to frontends enables and event-driven UX design, effectively extending the idea of <a href="https://en.wikipedia.org/wiki/Event-driven_architecture">event-driven architecture</a> to the UI.</p>
<p>We believe that hiding asynchronism by turning it into a fake synchronous process is an anti-pattern. For example, sending money from one bank account to another doesn't happen instantaneously, but with at least two events: &quot;transfer requested&quot; and &quot;transfer completed&quot; (or &quot;transfer failed&quot;). Acknowledging this when designing the UI leads to a more natural user experience and less loading indicators.</p>
<p>On the other hand, it is also known that doing the opposite is an anti-pattern as well. For example, submitting a request form to send money around is very likely a synchronous action on the frontend - even though the actual transfer won't be completed immediately, the client typically wants to know whether the request got accepted or not. While it would work to model this with a &quot;request form submitted&quot; event, it introduces unnecessary complexity: waiting for the response, as well as reacting to not having received a response within a selected time frame, is arguably harder to implement than simply using a synchronous (HTTP) request instead.</p>
<p>Consequently, we've settled on the rather pragmatic approach of combining synchronous requests with synchronous <em>and</em> asynchronous responses, depending on the use case at hand.</p>
<p>With that in mind, adding a reverse-proxy (&quot;API Gateway&quot;) capability to RIG seemed like a natural extension. After all, RIG already dealt with sessions (and blacklisting them) and it made sense to employ the same checks for synchronous requests towards the backend.</p>
<h2><a class="anchor" aria-hidden="true" id="dealing-with-connection-loss"></a><a href="#dealing-with-connection-loss" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dealing with Connection Loss</h2>
<p>When frontends rely on events to update their state, they must either never miss an event, or they must be able to deal with lost events. Clearly, never missing an event is not possible (lossy mobile connections, network roaming, etc.). So the question is: how to notice and react to lost events?</p>
<h3><a class="anchor" aria-hidden="true" id="notice-lost-events-on-a-server-sent-events-connection"></a><a href="#notice-lost-events-on-a-server-sent-events-connection" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Notice lost events on a Server-Sent Events connection</h3>
<p>Your frontend should be able to notice lost events quite easily:</p>
<ul>
<li>The <a href="https://html.spec.whatwg.org/multipage/server-sent-events.html#handler-eventsource-onerror"><code>EventSource</code> interface offers an <code>onerror</code> callback</a> that can be used to find out about network errors.</li>
<li>Whenever a connection is (re-)established, RIG emits an event of type &quot;rig.connection.create&quot;.</li>
</ul>
<p>Make sure you handle both the callback and RIG's event.</p>
<h3><a class="anchor" aria-hidden="true" id="react-to-lost-events"></a><a href="#react-to-lost-events" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>React to lost events</h3>
<p>As soon as the (SSE) connection to RIG has been (re-)established, the frontend should setup any manual subscriptions with RIG and use HTTP calls towards back-end services to refresh its state. After that, incoming events can be applied to the local state.</p>
<p>When the response to a synchronous request interleaves with incoming events, it may become tricky to infer the state your frontend should be in. Unfortunately, how to solve this problem pretty much depends on the domain and types of events you're dealing with, so there is no silver-bullet solution. Ideas that could work for you:</p>
<ul>
<li>When sourcing events on the frontend, deduplicate events by their event ID (per source/producer).</li>
<li>Have the producer add a timestamp to the synchronous response and compare that to the event's time field (per source/producer).</li>
<li>Don't use events for updating the state, but rather as a trigger for fetching the newest data from the source/producer service using an HTTP call.</li>
</ul>
<p>Likely you'll need to apply different patterns for different events and data in your application.</p>
<h2><a class="anchor" aria-hidden="true" id="providing-a-synchronous-api-for-asynchronous-back-end-services"></a><a href="#providing-a-synchronous-api-for-asynchronous-back-end-services" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Providing a Synchronous API for Asynchronous Back-End Services</h2>
<p>The good old public REST API is still common, so you cannot always rely on Server-Sent Events or WebSocket to communicate asynchronous events. Going back to the previous example of sending money from one bank account to another, an external service that triggers such a transfer through your RESTful web interface might indeed want to wait for the whole process to complete, regardless of how many events and services are actually involved. That's exactly what we've described as an anti-pattern above, but for a public API there's little we can do about it.</p>
<p>To support this use case, RIG is able to &quot;convert&quot; HTTP calls to Kafka events. Optionally, RIG also waits for a corresponding response event from a Kafka topic. Using the example again, this might look like this:</p>
<ol>
<li>The third-party client sends an HTTP request to RIG</li>
<li>RIG produces a request event to a Kafka topic, adding a correlation ID representing the client connection</li>
<li>A service picks up the request and emits a &quot;processed&quot; event, retaining RIG's correlation ID</li>
<li>RIG listens on a Kafka topic for events that have a correlation ID set, picks up the &quot;processed&quot; event and sends it as a response down the still-open HTTP connection to the waiting third-party client.</li>
</ol>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/reactive-interaction-gateway/docs/faq.html"><span class="arrow-prev">← </span><span>FAQ</span></a><a class="docs-next button" href="/reactive-interaction-gateway/docs/api-gateway.html"><span>API Gateway</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#the-problem">The Problem</a></li><li><a href="#event-driven-architecture-and-the-ui">Event-Driven Architecture and the UI</a></li><li><a href="#dealing-with-connection-loss">Dealing with Connection Loss</a><ul class="toc-headings"><li><a href="#notice-lost-events-on-a-server-sent-events-connection">Notice lost events on a Server-Sent Events connection</a></li><li><a href="#react-to-lost-events">React to lost events</a></li></ul></li><li><a href="#providing-a-synchronous-api-for-asynchronous-back-end-services">Providing a Synchronous API for Asynchronous Back-End Services</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/reactive-interaction-gateway/" class="nav-home"></a><div><h5>Docs</h5><a href="/reactive-interaction-gateway/docs/en/intro.html">Intro</a><a href="/reactive-interaction-gateway/docs/en/getting-started.html">Getting Started</a></div><div><h5>Community</h5><a href="/reactive-interaction-gateway/en/users.html">User Showcase</a><a href="http://stackoverflow.com/questions/tagged/reactive-interaction-gateway" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://twitter.com/kevnbadr" target="_blank" rel="noreferrer noopener">@KevnBadr</a></div><div><h5>More</h5><a class="github-button" href="https://github.com/accenture/reactive-interaction-gateway" data-icon="octicon-star" data-count-href="/accenture/reactive-interaction-gateway/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star RIG on GitHub">Star RIG on GitHub</a></div></section><section class="copyright">Copyright © 2019 Accenture</section></footer></div></body></html>